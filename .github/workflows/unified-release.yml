name: Unified Release

# Single workflow dispatch that stamps ONE version across all repos,
# triggers Docker builds via workflow_dispatch, polls for completion,
# then packages the OVA bundle for GCS deployment.

on:
  workflow_dispatch:
    inputs:
      version:
        description: "Release version stamped on ALL repos (e.g., 0.8.6-rc49)"
        required: true
        type: string
      target_branch:
        description: "Target branch in component repos"
        required: false
        type: string
        default: "0.8.6-release"
      ct_media_version:
        description: "ct-media version override (leave empty to use unified version)"
        required: false
        type: string
      skip_component_releases:
        description: "Skip creating GitHub releases (use existing tags/images)"
        type: boolean
        default: false
      skip_docker_builds:
        description: "Skip Docker builds (use existing images)"
        type: boolean
        default: false

jobs:
  # ─────────────────────────────────────────────────────────────────
  # Job 1: Create GitHub releases in all component repos
  # ─────────────────────────────────────────────────────────────────
  create-releases:
    if: ${{ !inputs.skip_component_releases }}
    runs-on: ubuntu-latest
    steps:
      - name: Create cisco-cdr release
        env:
          GH_TOKEN: ${{ secrets.GH_RELEASE_TOKEN }}
        run: |
          echo "Creating cisco-cdr release: ${{ inputs.version }}"
          gh release create "${{ inputs.version }}" \
            --repo calltelemetry/cisco-cdr \
            --target "${{ inputs.target_branch }}" \
            --title "${{ inputs.version }}" \
            --prerelease \
            --notes "Unified release ${{ inputs.version }}"

      - name: Create ct-quasar release
        env:
          GH_TOKEN: ${{ secrets.GH_RELEASE_TOKEN }}
        run: |
          echo "Creating ct-quasar release: ${{ inputs.version }}"
          gh release create "${{ inputs.version }}" \
            --repo calltelemetry/ct-quasar \
            --target "${{ inputs.target_branch }}" \
            --title "${{ inputs.version }}" \
            --prerelease \
            --notes "Unified release ${{ inputs.version }}"

      - name: Create jtapi-sidecar release
        env:
          GH_TOKEN: ${{ secrets.GH_RELEASE_TOKEN }}
        run: |
          echo "Creating jtapi-sidecar release: ${{ inputs.version }}"
          gh release create "${{ inputs.version }}" \
            --repo calltelemetry/jtapi-sidecar \
            --target "${{ inputs.target_branch }}" \
            --title "${{ inputs.version }}" \
            --prerelease \
            --notes "Unified release ${{ inputs.version }}"

      - name: Create ct-media release
        env:
          GH_TOKEN: ${{ secrets.GH_RELEASE_TOKEN }}
        run: |
          CT_MEDIA_TAG="${{ inputs.ct_media_version || inputs.version }}"
          echo "Creating ct-media release: $CT_MEDIA_TAG"
          gh release create "$CT_MEDIA_TAG" \
            --repo calltelemetry/ct-media \
            --target "${{ inputs.target_branch }}" \
            --title "$CT_MEDIA_TAG" \
            --prerelease \
            --notes "Unified release $CT_MEDIA_TAG"

      - name: Summary
        run: |
          CT_MEDIA_TAG="${{ inputs.ct_media_version || inputs.version }}"
          echo "### Releases Created" >> $GITHUB_STEP_SUMMARY
          echo "| Repo | Tag | Branch |" >> $GITHUB_STEP_SUMMARY
          echo "|------|-----|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| cisco-cdr | ${{ inputs.version }} | ${{ inputs.target_branch }} |" >> $GITHUB_STEP_SUMMARY
          echo "| ct-quasar | ${{ inputs.version }} | ${{ inputs.target_branch }} |" >> $GITHUB_STEP_SUMMARY
          echo "| jtapi-sidecar | ${{ inputs.version }} | ${{ inputs.target_branch }} |" >> $GITHUB_STEP_SUMMARY
          echo "| ct-media | $CT_MEDIA_TAG | ${{ inputs.target_branch }} |" >> $GITHUB_STEP_SUMMARY

  # ─────────────────────────────────────────────────────────────────
  # Job 2: Trigger Docker builds and wait for completion
  # Uses workflow_dispatch + polling (private repos can't use workflow_call)
  # ─────────────────────────────────────────────────────────────────
  build-images:
    needs: create-releases
    if: ${{ !inputs.skip_docker_builds && always() && (needs.create-releases.result == 'success' || needs.create-releases.result == 'skipped') }}
    runs-on: ubuntu-latest
    steps:
      - name: Trigger all Docker builds
        id: trigger
        env:
          GH_TOKEN: ${{ secrets.GH_RELEASE_TOKEN }}
        run: |
          VERSION="${{ inputs.version }}"
          CT_MEDIA_TAG="${{ inputs.ct_media_version || inputs.version }}"

          echo "Triggering Docker builds for version: $VERSION"
          echo "  ct-media version: $CT_MEDIA_TAG"
          echo ""

          gh workflow run docker-backend-release.yaml \
            --repo calltelemetry/cisco-cdr \
            -f tag_name="$VERSION"
          echo "  cisco-cdr: triggered"

          gh workflow run publish_docker.yaml \
            --repo calltelemetry/ct-quasar \
            -f tag_name="$VERSION"
          echo "  ct-quasar: triggered"

          gh workflow run docker-release.yml \
            --repo calltelemetry/jtapi-sidecar \
            -f tag_name="$VERSION"
          echo "  jtapi-sidecar: triggered"

          gh workflow run docker-release.yml \
            --repo calltelemetry/ct-media \
            -f tag_name="$CT_MEDIA_TAG"
          echo "  ct-media: triggered"

          echo ""
          echo "All builds triggered at $(date -u '+%H:%M:%S UTC')"

      - name: Capture run IDs
        id: runs
        env:
          GH_TOKEN: ${{ secrets.GH_RELEASE_TOKEN }}
        run: |
          # Wait for GitHub to register the workflow runs
          echo "Waiting 15s for workflow runs to register..."
          sleep 15

          capture_run_id() {
            local REPO="$1" WORKFLOW="$2" LABEL="$3"
            local RUN_ID
            RUN_ID=$(gh run list --repo "$REPO" --workflow "$WORKFLOW" \
              --limit 1 --json databaseId --jq '.[0].databaseId' 2>/dev/null)
            if [ -z "$RUN_ID" ] || [ "$RUN_ID" = "null" ]; then
              echo "::error::Failed to capture run ID for $LABEL"
              exit 1
            fi
            echo "  $LABEL: run $RUN_ID"
            echo "${LABEL}_run_id=$RUN_ID" >> "$GITHUB_OUTPUT"
          }

          capture_run_id "calltelemetry/cisco-cdr" "docker-backend-release.yaml" "cisco_cdr"
          capture_run_id "calltelemetry/ct-quasar" "publish_docker.yaml" "ct_quasar"
          capture_run_id "calltelemetry/jtapi-sidecar" "docker-release.yml" "jtapi_sidecar"
          capture_run_id "calltelemetry/ct-media" "docker-release.yml" "ct_media"

          echo ""
          echo "All run IDs captured."

      - name: Poll builds until complete
        env:
          GH_TOKEN: ${{ secrets.GH_RELEASE_TOKEN }}
        run: |
          echo "Polling Docker builds for completion..."
          echo ""

          # Build entries: "label:repo:run_id"
          BUILDS=( \
            "cisco-cdr:calltelemetry/cisco-cdr:${{ steps.runs.outputs.cisco_cdr_run_id }}" \
            "ct-quasar:calltelemetry/ct-quasar:${{ steps.runs.outputs.ct_quasar_run_id }}" \
            "jtapi-sidecar:calltelemetry/jtapi-sidecar:${{ steps.runs.outputs.jtapi_sidecar_run_id }}" \
            "ct-media:calltelemetry/ct-media:${{ steps.runs.outputs.ct_media_run_id }}" \
          )

          MAX_WAIT=2400  # 40 minutes
          POLL_INTERVAL=30
          ELAPSED=0
          ALL_DONE=false
          FAILED=false
          declare -A DONE_MAP

          while [ "$ALL_DONE" != "true" ] && [ $ELAPSED -lt $MAX_WAIT ]; do
            ALL_DONE=true
            for entry in "${BUILDS[@]}"; do
              LABEL="${entry%%:*}"
              REST="${entry#*:}"
              REPO="${REST%%:*}"
              RUN_ID="${REST##*:}"

              # Skip already-completed builds
              if [ "${DONE_MAP[$LABEL]}" = "done" ]; then
                continue
              fi

              STATUS=$(gh run view "$RUN_ID" --repo "$REPO" \
                --json status,conclusion \
                --jq '"\(.status):\(.conclusion // "pending")"' 2>/dev/null || echo "unknown:unknown")

              RUN_STATUS="${STATUS%%:*}"
              RUN_CONCLUSION="${STATUS##*:}"

              if [ "$RUN_STATUS" = "completed" ]; then
                DONE_MAP[$LABEL]="done"
                if [ "$RUN_CONCLUSION" = "success" ]; then
                  echo "  $LABEL: completed (success) [run $RUN_ID]"
                else
                  echo "  $LABEL: FAILED ($RUN_CONCLUSION) [run $RUN_ID]"
                  echo "::error::$LABEL build failed with conclusion: $RUN_CONCLUSION — https://github.com/$REPO/actions/runs/$RUN_ID"
                  FAILED=true
                fi
              else
                echo "  $LABEL: $RUN_STATUS [run $RUN_ID]"
                ALL_DONE=false
              fi
            done

            if [ "$ALL_DONE" != "true" ]; then
              echo "  --- Waiting ${POLL_INTERVAL}s (${ELAPSED}s / ${MAX_WAIT}s) ---"
              sleep $POLL_INTERVAL
              ELAPSED=$((ELAPSED + POLL_INTERVAL))
            fi
          done

          echo ""

          # Hard fail on any build failure
          if [ "$FAILED" = "true" ]; then
            echo "::error::One or more Docker builds failed — aborting release"
            exit 1
          fi

          # Hard fail on timeout
          if [ "$ALL_DONE" != "true" ]; then
            echo "::error::Timed out waiting for Docker builds after ${MAX_WAIT}s — aborting release"
            exit 1
          fi

          echo "All Docker builds completed successfully."

      - name: Resolve ct-media version
        id: ct_media
        run: |
          CT_MEDIA_TAG="${{ inputs.ct_media_version || inputs.version }}"
          echo "version=$CT_MEDIA_TAG" >> "$GITHUB_OUTPUT"
          echo "ct-media version: $CT_MEDIA_TAG"

      - name: Verify images exist on Docker Hub
        run: |
          VERSION="${{ inputs.version }}"
          CT_MEDIA="${{ steps.ct_media.outputs.version }}"
          echo "Verifying Docker Hub images..."

          IMAGES=("calltelemetry/web:$VERSION" \
                  "calltelemetry/vue:$VERSION" \
                  "calltelemetry/jtapi-sidecar:$VERSION" \
                  "calltelemetry/ct-media:$CT_MEDIA")

          ALL_FOUND=true
          for IMAGE in "${IMAGES[@]}"; do
            if docker manifest inspect "$IMAGE" > /dev/null 2>&1; then
              echo "  $IMAGE: found"
            else
              echo "  $IMAGE: NOT FOUND"
              ALL_FOUND=false
            fi
          done

          if [ "$ALL_FOUND" != "true" ]; then
            echo "::error::Some images not found on Docker Hub — cannot create OVA release"
            exit 1
          fi

          echo "All images verified on Docker Hub."
    outputs:
      ct_media_version: ${{ steps.ct_media.outputs.version }}

  # ─────────────────────────────────────────────────────────────────
  # Job 3: Trigger OVA release (creates version yaml + GCS bundle)
  # ─────────────────────────────────────────────────────────────────
  create-ova-release:
    needs: [build-images]
    if: ${{ always() && (needs.build-images.result == 'success' || needs.build-images.result == 'skipped') }}
    runs-on: ubuntu-latest
    steps:
      - name: Resolve ct-media version
        id: resolve
        run: |
          CT_MEDIA="${{ needs.build-images.outputs.ct_media_version || inputs.ct_media_version || inputs.version }}"
          echo "ct_media=$CT_MEDIA" >> "$GITHUB_OUTPUT"
          echo "ct-media version for OVA: $CT_MEDIA"

      - name: Trigger OVA release
        env:
          GH_TOKEN: ${{ secrets.GH_RELEASE_TOKEN }}
        run: |
          echo "Triggering OVA release: ${{ inputs.version }}"
          echo "  jtapi_version: ${{ inputs.version }}"
          echo "  ct_media_version: ${{ steps.resolve.outputs.ct_media }}"
          gh workflow run create-ova-release.yml \
            --repo calltelemetry/calltelemetry \
            -f version="${{ inputs.version }}" \
            -f jtapi_version="${{ inputs.version }}" \
            -f ct_media_version="${{ steps.resolve.outputs.ct_media }}"

      - name: Summary
        run: |
          echo "### Unified Release: ${{ inputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Image | Tag |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|-----|" >> $GITHUB_STEP_SUMMARY
          echo "| calltelemetry/web | ${{ inputs.version }} |" >> $GITHUB_STEP_SUMMARY
          echo "| calltelemetry/vue | ${{ inputs.version }} |" >> $GITHUB_STEP_SUMMARY
          echo "| calltelemetry/jtapi-sidecar | ${{ inputs.version }} |" >> $GITHUB_STEP_SUMMARY
          echo "| calltelemetry/ct-media | ${{ steps.resolve.outputs.ct_media }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "OVA release triggered. Monitor \`create-ova-release\` and \`package-release\` workflows for completion." >> $GITHUB_STEP_SUMMARY
