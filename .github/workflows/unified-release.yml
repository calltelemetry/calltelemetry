name: Unified Release

# Single workflow dispatch that stamps ONE version across all repos,
# triggers Docker builds via workflow_dispatch, polls for completion,
# then packages the OVA bundle for GCS deployment.

on:
  workflow_dispatch:
    inputs:
      version:
        description: "Release version stamped on ALL repos (e.g., 0.8.6-rc49)"
        required: true
        type: string
      target_branch:
        description: "Target branch in component repos"
        required: false
        type: string
        default: "0.8.6-release"
      ct_media_version:
        description: "ct-media version override (leave empty to keep current: 0.2.5)"
        required: false
        type: string
      skip_component_releases:
        description: "Skip creating GitHub releases (use existing tags/images)"
        type: boolean
        default: false
      skip_docker_builds:
        description: "Skip Docker builds (use existing images)"
        type: boolean
        default: false

jobs:
  # ─────────────────────────────────────────────────────────────────
  # Job 1: Create GitHub releases in all component repos
  # ─────────────────────────────────────────────────────────────────
  create-releases:
    if: ${{ !inputs.skip_component_releases }}
    runs-on: ubuntu-latest
    steps:
      - name: Create cisco-cdr release
        env:
          GH_TOKEN: ${{ secrets.GH_RELEASE_TOKEN }}
        run: |
          echo "Creating cisco-cdr release: ${{ inputs.version }}"
          gh release create "${{ inputs.version }}" \
            --repo calltelemetry/cisco-cdr \
            --target "${{ inputs.target_branch }}" \
            --title "${{ inputs.version }}" \
            --latest \
            --notes "Unified release ${{ inputs.version }}"

      - name: Create ct-quasar release
        env:
          GH_TOKEN: ${{ secrets.GH_RELEASE_TOKEN }}
        run: |
          echo "Creating ct-quasar release: ${{ inputs.version }}"
          gh release create "${{ inputs.version }}" \
            --repo calltelemetry/ct-quasar \
            --target "${{ inputs.target_branch }}" \
            --title "${{ inputs.version }}" \
            --latest \
            --notes "Unified release ${{ inputs.version }}"

      - name: Create jtapi-sidecar release
        env:
          GH_TOKEN: ${{ secrets.GH_RELEASE_TOKEN }}
        run: |
          echo "Creating jtapi-sidecar release: ${{ inputs.version }}"
          gh release create "${{ inputs.version }}" \
            --repo calltelemetry/jtapi-sidecar \
            --target "${{ inputs.target_branch }}" \
            --title "${{ inputs.version }}" \
            --latest \
            --notes "Unified release ${{ inputs.version }}"

      - name: Summary
        run: |
          echo "### Releases Created" >> $GITHUB_STEP_SUMMARY
          echo "| Repo | Tag | Branch |" >> $GITHUB_STEP_SUMMARY
          echo "|------|-----|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| cisco-cdr | ${{ inputs.version }} | ${{ inputs.target_branch }} |" >> $GITHUB_STEP_SUMMARY
          echo "| ct-quasar | ${{ inputs.version }} | ${{ inputs.target_branch }} |" >> $GITHUB_STEP_SUMMARY
          echo "| jtapi-sidecar | ${{ inputs.version }} | ${{ inputs.target_branch }} |" >> $GITHUB_STEP_SUMMARY

  # ─────────────────────────────────────────────────────────────────
  # Job 2: Trigger Docker builds and wait for completion
  # Uses workflow_dispatch + polling (private repos can't use workflow_call)
  # ─────────────────────────────────────────────────────────────────
  build-images:
    needs: create-releases
    if: ${{ !inputs.skip_docker_builds && always() && (needs.create-releases.result == 'success' || needs.create-releases.result == 'skipped') }}
    runs-on: ubuntu-latest
    steps:
      - name: Trigger cisco-cdr Docker build
        env:
          GH_TOKEN: ${{ secrets.GH_RELEASE_TOKEN }}
        run: |
          echo "Triggering cisco-cdr Docker build: ${{ inputs.version }}"
          gh workflow run docker-backend-release.yaml \
            --repo calltelemetry/cisco-cdr \
            -f tag_name="${{ inputs.version }}"

      - name: Trigger ct-quasar Docker build
        env:
          GH_TOKEN: ${{ secrets.GH_RELEASE_TOKEN }}
        run: |
          echo "Triggering ct-quasar Docker build: ${{ inputs.version }}"
          gh workflow run publish_docker.yaml \
            --repo calltelemetry/ct-quasar \
            -f tag_name="${{ inputs.version }}"

      - name: Trigger jtapi-sidecar Docker build
        env:
          GH_TOKEN: ${{ secrets.GH_RELEASE_TOKEN }}
        run: |
          echo "Triggering jtapi-sidecar Docker build: ${{ inputs.version }}"
          gh workflow run build.yml \
            --repo calltelemetry/jtapi-sidecar \
            -f tag_name="${{ inputs.version }}"

      - name: Wait for builds to complete
        env:
          GH_TOKEN: ${{ secrets.GH_RELEASE_TOKEN }}
        run: |
          echo "Waiting for Docker builds to complete..."
          echo "Builds triggered at $(date -u '+%H:%M:%S UTC')"
          echo ""

          # Give workflows time to start
          sleep 30

          # Poll each repo for the most recent workflow run matching our version
          REPOS=("calltelemetry/cisco-cdr:docker-backend-release.yaml" \
                 "calltelemetry/ct-quasar:publish_docker.yaml" \
                 "calltelemetry/jtapi-sidecar:build.yml")

          MAX_WAIT=2400  # 40 minutes
          POLL_INTERVAL=30
          ELAPSED=0
          ALL_DONE=false

          while [ "$ALL_DONE" != "true" ] && [ $ELAPSED -lt $MAX_WAIT ]; do
            ALL_DONE=true
            for entry in "${REPOS[@]}"; do
              REPO="${entry%%:*}"
              WORKFLOW="${entry##*:}"
              SHORT_NAME="${REPO##*/}"

              # Get most recent run for this workflow
              STATUS=$(gh run list --repo "$REPO" --workflow "$WORKFLOW" \
                --limit 1 --json status,conclusion,headBranch \
                --jq '.[0] | "\(.status):\(.conclusion // "pending")"' 2>/dev/null || echo "unknown:unknown")

              RUN_STATUS="${STATUS%%:*}"
              RUN_CONCLUSION="${STATUS##*:}"

              if [ "$RUN_STATUS" = "completed" ]; then
                if [ "$RUN_CONCLUSION" = "success" ]; then
                  echo "  $SHORT_NAME: completed (success)"
                else
                  echo "  $SHORT_NAME: completed ($RUN_CONCLUSION)"
                  echo "::error::$SHORT_NAME build failed with conclusion: $RUN_CONCLUSION"
                fi
              else
                echo "  $SHORT_NAME: $RUN_STATUS"
                ALL_DONE=false
              fi
            done

            if [ "$ALL_DONE" != "true" ]; then
              echo "  --- Waiting ${POLL_INTERVAL}s (${ELAPSED}s / ${MAX_WAIT}s) ---"
              sleep $POLL_INTERVAL
              ELAPSED=$((ELAPSED + POLL_INTERVAL))
            fi
          done

          echo ""
          if [ "$ALL_DONE" = "true" ]; then
            echo "All Docker builds completed."
          else
            echo "::warning::Timed out waiting for builds after ${MAX_WAIT}s"
          fi

      - name: Verify images exist on Docker Hub
        run: |
          VERSION="${{ inputs.version }}"
          echo "Verifying Docker Hub images for $VERSION..."

          IMAGES=("calltelemetry/web:$VERSION" \
                  "calltelemetry/vue:$VERSION" \
                  "calltelemetry/jtapi-sidecar:$VERSION")

          ALL_FOUND=true
          for IMAGE in "${IMAGES[@]}"; do
            if docker manifest inspect "$IMAGE" > /dev/null 2>&1; then
              echo "  $IMAGE: found"
            else
              echo "  $IMAGE: NOT FOUND"
              ALL_FOUND=false
            fi
          done

          if [ "$ALL_FOUND" != "true" ]; then
            echo "::warning::Some images not found on Docker Hub — OVA release may use stale images"
          fi

  # ─────────────────────────────────────────────────────────────────
  # Job 3: Trigger OVA release (creates version yaml + GCS bundle)
  # ─────────────────────────────────────────────────────────────────
  create-ova-release:
    needs: [build-images]
    if: ${{ always() && (needs.build-images.result == 'success' || needs.build-images.result == 'skipped') }}
    runs-on: ubuntu-latest
    steps:
      - name: Resolve ct-media version
        id: resolve
        run: |
          if [ -n "${{ inputs.ct_media_version }}" ]; then
            echo "ct_media=${{ inputs.ct_media_version }}" >> "$GITHUB_OUTPUT"
          else
            echo "ct_media=0.2.5" >> "$GITHUB_OUTPUT"
          fi

      - name: Trigger OVA release
        env:
          GH_TOKEN: ${{ secrets.GH_RELEASE_TOKEN }}
        run: |
          echo "Triggering OVA release: ${{ inputs.version }}"
          echo "  jtapi_version: ${{ inputs.version }}"
          echo "  ct_media_version: ${{ steps.resolve.outputs.ct_media }}"
          gh workflow run create-ova-release.yml \
            --repo calltelemetry/calltelemetry \
            -f version="${{ inputs.version }}" \
            -f jtapi_version="${{ inputs.version }}" \
            -f ct_media_version="${{ steps.resolve.outputs.ct_media }}"

      - name: Summary
        run: |
          echo "### Unified Release: ${{ inputs.version }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Image | Tag |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|-----|" >> $GITHUB_STEP_SUMMARY
          echo "| calltelemetry/web | ${{ inputs.version }} |" >> $GITHUB_STEP_SUMMARY
          echo "| calltelemetry/vue | ${{ inputs.version }} |" >> $GITHUB_STEP_SUMMARY
          echo "| calltelemetry/jtapi-sidecar | ${{ inputs.version }} |" >> $GITHUB_STEP_SUMMARY
          echo "| calltelemetry/ct-media | ${{ steps.resolve.outputs.ct_media }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "OVA release triggered. Monitor \`create-ova-release\` and \`package-release\` workflows for completion." >> $GITHUB_STEP_SUMMARY
