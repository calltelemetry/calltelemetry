name: Package Release Bundle

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      version:
        description: 'Version tag to package (e.g., 0.8.4-rc191)'
        required: true
        type: string
      stable:
        description: 'Mark as stable release (updates latest-stable.txt)'
        required: false
        type: boolean
        default: false

env:
  GCS_BUCKET: ${{ secrets.GCS_BUCKET }}
  BUNDLE_NAME: calltelemetry-bundle

jobs:
  package-and-upload:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      id-token: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Determine version
        id: version
        run: |
          if [ "${{ github.event_name }}" = "release" ]; then
            VERSION="${{ github.event.release.tag_name }}"
          else
            VERSION="${{ inputs.version }}"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "ðŸ“¦ Packaging version: $VERSION"

      - name: Create bundle directory
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          BUNDLE_DIR="${BUNDLE_NAME}-${VERSION}"

          mkdir -p "$BUNDLE_DIR"
          echo "ðŸ“ Created bundle directory: $BUNDLE_DIR"

      - name: Install yq for YAML parsing
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      - name: Copy files from manifest
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          BUNDLE_DIR="${BUNDLE_NAME}-${VERSION}"
          MANIFEST="ova/bundle-manifest.yml"

          if [ ! -f "$MANIFEST" ]; then
            echo "âŒ Manifest not found: $MANIFEST"
            exit 1
          fi

          echo "ðŸ“‹ Reading manifest: $MANIFEST"

          # Copy scripts
          echo "--- Scripts ---"
          for script in $(yq '.scripts[]' "$MANIFEST" 2>/dev/null); do
            if [ -f "ova/$script" ]; then
              cp "ova/$script" "$BUNDLE_DIR/"
              chmod +x "$BUNDLE_DIR/$script"
              echo "âœ… $script"
            else
              echo "âš ï¸  Missing: ova/$script"
            fi
          done

          # Copy configs
          echo "--- Configs ---"
          for config in $(yq '.configs[]' "$MANIFEST" 2>/dev/null); do
            if [ -f "ova/$config" ]; then
              cp "ova/$config" "$BUNDLE_DIR/"
              echo "âœ… $(basename $config)"
            else
              echo "âš ï¸  Missing: ova/$config"
            fi
          done

          # Copy prometheus
          echo "--- Prometheus ---"
          mkdir -p "$BUNDLE_DIR/prometheus"
          for file in $(yq '.prometheus[]' "$MANIFEST" 2>/dev/null); do
            if [ -f "ova/$file" ]; then
              cp "ova/$file" "$BUNDLE_DIR/prometheus/"
              echo "âœ… $(basename $file)"
            fi
          done

          # Copy grafana dashboards
          echo "--- Grafana Dashboards ---"
          mkdir -p "$BUNDLE_DIR/grafana/dashboards"
          for file in $(yq '.grafana.dashboards[]' "$MANIFEST" 2>/dev/null); do
            if [ -f "ova/$file" ]; then
              cp "ova/$file" "$BUNDLE_DIR/grafana/dashboards/"
              echo "âœ… $(basename $file)"
            fi
          done

          # Copy grafana provisioning
          echo "--- Grafana Provisioning ---"
          mkdir -p "$BUNDLE_DIR/grafana/provisioning/datasources"
          mkdir -p "$BUNDLE_DIR/grafana/provisioning/dashboards"
          for file in $(yq '.grafana.provisioning[]' "$MANIFEST" 2>/dev/null); do
            if [ -f "ova/$file" ]; then
              # Determine subdirectory from path
              if echo "$file" | grep -q "datasources"; then
                cp "ova/$file" "$BUNDLE_DIR/grafana/provisioning/datasources/"
              elif echo "$file" | grep -q "dashboards"; then
                cp "ova/$file" "$BUNDLE_DIR/grafana/provisioning/dashboards/"
              fi
              echo "âœ… $(basename $file)"
            fi
          done

      - name: Copy JTAPI overlay
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          BUNDLE_DIR="${BUNDLE_NAME}-${VERSION}"
          MANIFEST="ova/bundle-manifest.yml"

          echo "--- JTAPI ---"
          for file in $(yq '.jtapi[]' "$MANIFEST" 2>/dev/null); do
            if [ -f "$file" ]; then
              cp "$file" "$BUNDLE_DIR/"
              echo "âœ… $(basename $file)"
            else
              echo "âš ï¸  Missing: $file (JTAPI overlay not found at repo root)"
            fi
          done

      - name: Pin JTAPI overlay versions from version YAML
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          BUNDLE_DIR="${BUNDLE_NAME}-${VERSION}"
          OVERLAY="$BUNDLE_DIR/docker-compose-jtapi.yml"

          # Only pin if the overlay was copied into the bundle
          if [ ! -f "$OVERLAY" ]; then
            echo "â„¹ï¸  No JTAPI overlay in bundle, skipping version pinning"
            exit 0
          fi

          # Extract JTAPI/ct-media versions from the version YAML if they exist
          # This handles the case where create-ova-release already pinned them
          # and the overlay was committed with pinned versions
          if grep -q 'JTAPI_VERSION:-latest' "$OVERLAY"; then
            echo "âš ï¸  JTAPI overlay still has :latest defaults â€” versions not pinned"
            echo "   Pin versions by providing jtapi_version and ct_media_version"
            echo "   when running the Create OVA Release workflow"
          else
            echo "âœ… JTAPI overlay has pinned versions:"
            grep 'image:' "$OVERLAY"
          fi

      - name: Verify version-specific compose exists
        run: |
          VERSION="${{ steps.version.outputs.version }}"

          # REQUIRE version-specific compose file - no fallbacks
          if [ -f "ova/versions/${VERSION}.yml" ]; then
            echo "âœ… Found: ova/versions/${VERSION}.yml"
          elif [ -f "ova/versions/${VERSION}.yaml" ]; then
            echo "âœ… Found: ova/versions/${VERSION}.yaml"
          else
            echo ""
            echo "âŒ ERROR: No docker-compose file found for version ${VERSION}"
            echo ""
            echo "Expected one of:"
            echo "  - ova/versions/${VERSION}.yml"
            echo "  - ova/versions/${VERSION}.yaml"
            echo ""
            echo "Available versions:"
            ls -1 ova/versions/*.yml ova/versions/*.yaml 2>/dev/null | grep -v "prometheus" | grep -v "caddy" | head -20 || echo "  (none)"
            echo ""
            echo "Create the version file first before running this workflow."
            exit 1
          fi

      - name: Copy docker-compose for version
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          BUNDLE_DIR="${BUNDLE_NAME}-${VERSION}"

          if [ -f "ova/versions/${VERSION}.yml" ]; then
            cp "ova/versions/${VERSION}.yml" "$BUNDLE_DIR/docker-compose.yml"
            echo "âœ… Copied: ova/versions/${VERSION}.yml"
          else
            cp "ova/versions/${VERSION}.yaml" "$BUNDLE_DIR/docker-compose.yml"
            echo "âœ… Copied: ova/versions/${VERSION}.yaml"
          fi

          echo ""
          echo "ðŸ“‹ Bundle contents:"
          ls -laR "$BUNDLE_DIR/"

      - name: Create README for bundle
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          BUNDLE_DIR="${BUNDLE_NAME}-${VERSION}"

          cat > "$BUNDLE_DIR/README.txt" << EOF
          CallTelemetry Offline Bundle
          Version: ${VERSION}
          Created: $(date -u '+%Y-%m-%d %H:%M:%S UTC')

          Installation:
          1. Extract this bundle to your home directory
          2. Run: chmod +x cli.sh
          3. Run: sudo ./cli.sh offline apply

          Or for online installation:
          1. Run: sudo ./cli.sh update ${VERSION}

          For help: ./cli.sh --help

          https://calltelemetry.com
          EOF
          echo "âœ… Created README.txt"

      - name: Create tar.gz bundle
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          BUNDLE_DIR="${BUNDLE_NAME}-${VERSION}"
          BUNDLE_FILE="${BUNDLE_NAME}-${VERSION}.tar.gz"

          tar -czvf "$BUNDLE_FILE" "$BUNDLE_DIR"

          echo "ðŸ“¦ Created bundle: $BUNDLE_FILE"
          echo "ðŸ“Š Bundle size: $(du -h $BUNDLE_FILE | cut -f1)"

          # Generate checksum
          sha256sum "$BUNDLE_FILE" > "${BUNDLE_FILE}.sha256"
          echo "ðŸ” SHA256: $(cat ${BUNDLE_FILE}.sha256)"

          echo "bundle_file=$BUNDLE_FILE" >> $GITHUB_ENV

      - name: Authenticate to Google Cloud
        if: env.GCS_BUCKET != ''
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCS_SERVICE_ACCOUNT_KEY }}

      - name: Set up Cloud SDK
        if: env.GCS_BUCKET != ''
        uses: google-github-actions/setup-gcloud@v2

      - name: Upload to Google Cloud Storage
        if: env.GCS_BUCKET != ''
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          BUNDLE_FILE="${BUNDLE_NAME}-${VERSION}.tar.gz"

          echo "â˜ï¸ Uploading to GCS bucket: $GCS_BUCKET"

          # Upload bundle to version-specific folder
          gsutil cp "$BUNDLE_FILE" "gs://${GCS_BUCKET}/releases/${VERSION}/"
          gsutil cp "${BUNDLE_FILE}.sha256" "gs://${GCS_BUCKET}/releases/${VERSION}/"

          # Upload cli.sh and prep.sh to bucket root (always latest)
          gsutil cp "ova/cli.sh" "gs://${GCS_BUCKET}/cli.sh"
          gsutil cp "ova/prep.sh" "gs://${GCS_BUCKET}/prep.sh"
          echo "âœ… Uploaded cli.sh and prep.sh to bucket root"

          # Upload postgres override files
          for pg_file in ova/postgres-*.yaml; do
            if [ -f "$pg_file" ]; then
              gsutil cp "$pg_file" "gs://${GCS_BUCKET}/$(basename $pg_file)"
              echo "âœ… Uploaded $(basename $pg_file)"
            fi
          done

          # Determine if this is a stable or pre-release
          # For release events: check prerelease flag
          # For workflow_dispatch: check stable input
          IS_STABLE="false"
          if [ "${{ github.event_name }}" = "release" ]; then
            if [ "${{ github.event.release.prerelease }}" != "true" ]; then
              IS_STABLE="true"
            fi
          else
            # workflow_dispatch - check stable input
            if [ "${{ inputs.stable }}" = "true" ]; then
              IS_STABLE="true"
            fi
          fi

          # Update only the appropriate version marker (they don't cross-update)
          if [ "$IS_STABLE" = "true" ]; then
            echo "$VERSION" > latest-stable.txt
            gsutil cp latest-stable.txt "gs://${GCS_BUCKET}/latest-stable.txt"
            gsutil cp "$BUNDLE_FILE" "gs://${GCS_BUCKET}/releases/latest/${BUNDLE_NAME}-latest.tar.gz"
            gsutil cp "${BUNDLE_FILE}.sha256" "gs://${GCS_BUCKET}/releases/latest/${BUNDLE_NAME}-latest.tar.gz.sha256"
            echo "âœ… Updated latest-stable.txt â†’ $VERSION"
          else
            echo "$VERSION" > latest.txt
            gsutil cp latest.txt "gs://${GCS_BUCKET}/latest.txt"
            echo "âœ… Updated latest.txt â†’ $VERSION"
          fi

          echo "âœ… Uploaded to GCS:"
          echo "   gs://${GCS_BUCKET}/releases/${VERSION}/${BUNDLE_FILE}"
          echo "   gs://${GCS_BUCKET}/cli.sh"
          echo "   gs://${GCS_BUCKET}/prep.sh"
          echo "   gs://${GCS_BUCKET}/latest.txt"

      - name: Upload bundle to GitHub Release
        if: github.event_name == 'release'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          BUNDLE_FILE="${BUNDLE_NAME}-${VERSION}.tar.gz"

          echo "ðŸ“¤ Uploading bundle to GitHub release..."

          gh release upload "$VERSION" \
            "$BUNDLE_FILE" \
            "${BUNDLE_FILE}.sha256" \
            --clobber

          echo "âœ… Uploaded to GitHub release: $VERSION"

      - name: Upload bundle as workflow artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.BUNDLE_NAME }}-${{ steps.version.outputs.version }}
          path: |
            ${{ env.BUNDLE_NAME }}-${{ steps.version.outputs.version }}.tar.gz
            ${{ env.BUNDLE_NAME }}-${{ steps.version.outputs.version }}.tar.gz.sha256
          retention-days: 90

      - name: Summary
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          BUNDLE_FILE="${BUNDLE_NAME}-${VERSION}.tar.gz"

          echo "## ðŸ“¦ Release Bundle Created" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** \`${VERSION}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Bundle:** \`${BUNDLE_FILE}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Size:** $(du -h $BUNDLE_FILE | cut -f1)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Contents" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          tar -tzf "$BUNDLE_FILE" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### SHA256 Checksum" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          cat "${BUNDLE_FILE}.sha256" >> $GITHUB_STEP_SUMMARY
          echo "\`\`\`" >> $GITHUB_STEP_SUMMARY

          if [ -n "$GCS_BUCKET" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Download URLs" >> $GITHUB_STEP_SUMMARY
            echo "- Bundle: \`gs://${GCS_BUCKET}/releases/${VERSION}/${BUNDLE_FILE}\`" >> $GITHUB_STEP_SUMMARY
            echo "- CLI: \`gs://${GCS_BUCKET}/cli.sh\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Public URLs" >> $GITHUB_STEP_SUMMARY
            echo "- Bundle: https://storage.googleapis.com/${GCS_BUCKET}/releases/${VERSION}/${BUNDLE_FILE}" >> $GITHUB_STEP_SUMMARY
            echo "- CLI: https://storage.googleapis.com/${GCS_BUCKET}/cli.sh" >> $GITHUB_STEP_SUMMARY
            echo "- Prep: https://storage.googleapis.com/${GCS_BUCKET}/prep.sh" >> $GITHUB_STEP_SUMMARY
          fi
